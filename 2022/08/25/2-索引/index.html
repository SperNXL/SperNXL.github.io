<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Arno Dorian">





<title>2_索引 | Arno&#39;blogs</title>



    <link rel="icon" href="/Cube.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="./iconfont.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Arno&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Arno&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">2_索引</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Arno Dorian</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">八月 25, 2022&nbsp;&nbsp;21:10:40</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/MySQL/">MySQL</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <hr>
<ul>
<li>索引概述</li>
<li>索引结构</li>
<li>索引分类</li>
<li>索引语法</li>
<li>SQL性能分析</li>
<li>索引使用</li>
<li>索引设计原则</li>
</ul>
<hr>
<h2 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h2><ul>
<li><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>类似查字典，<strong>索引（index）</strong>是帮助MySQL高效获取数据的数据结构(有序)。</p>
<p>在数据之外，数据库系统还维护着满足 特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。</p>
</li>
</ul>
<p>如下图</p>
<p><img src="BKNI0K%7BMRDEP$KS%5D9N%5B@0O5.png" alt="img"></p>
<p>下列语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age<span class="operator">=</span><span class="number">45</span>;</span><br></pre></td></tr></table></figure>

<p>如果不使用索引，将会进行<strong>全表扫描</strong></p>
<p>若使用索引</p>
<p><img src="tree.png" alt="tree"></p>
<p>45&gt;36走右子树，45小于48走左子树，只需要查询三次，效率提升</p>
<ul>
<li><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>优势</p>
<ul>
<li>提高数据检索的效率，降低数据库的IO成本</li>
<li>通过索引列对数据进行排序，降低 数据排序的成本，降低CPU的消耗。</li>
</ul>
<p>缺点</p>
<ul>
<li>索引列也是要占用空间的。</li>
<li>索引大大提高了查询效率，同时却也降低更新表的速度， 如对表进行INSERT(<strong>增</strong>)、DELETE(<strong>删</strong>)、UPDATE(<strong>改</strong>)时，效率降低。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><ul>
<li><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p>
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>B+Tree</td>
<td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td>
</tr>
<tr>
<td>Hash</td>
<td>底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不 支持范围查询</td>
</tr>
<tr>
<td>R-tree  (空间索引）</td>
<td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类 型，通常使用较少</td>
</tr>
<tr>
<td>Full-text  (全文索引)</td>
<td>是一种通过建立倒排索引,快速匹配文档的方式</td>
</tr>
</tbody></table>
<p>不同引擎对索引的支持情况</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>B+tree</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree</td>
<td>不支持</td>
<td>支出</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6版本之后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
</li>
<li><h3 id="B-Tree-多路平衡查找树"><a href="#B-Tree-多路平衡查找树" class="headerlink" title="B-Tree(多路平衡查找树)"></a>B-Tree(多路平衡查找树)</h3><p>B-Tree:  B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。</p>
<p><img src="B-Tree.png" alt="B-Tree"></p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>5阶的B树，每一个节点最多存储4个key，对应5个指针。</li>
<li>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</li>
<li>在B树中，<strong>非叶子节点和叶子节点都会存放数据</strong>。</li>
</ul>
</li>
<li><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一 下其结构示意图：</p>
<p><img src="B+tree.png" alt="B+tree"></p>
<ul>
<li>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。</li>
<li>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</li>
</ul>
<p>B+Tree 与 B-Tree相比，主要有以下三点区别：</p>
<ul>
<li>所有的数据都会出现在叶子节点。    如作为索引部分的  38、67、16、29，都在叶子结点重新出现</li>
<li>叶子节点形成一个单向链表</li>
<li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</li>
</ul>
</li>
<li><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash表中。</p>
<p><img src="hash.png" alt="hash"></p>
<p>其中  name 经过hash算法映射到槽位，b4a96就是常遇春的hash值</p>
<p>如果两个键值映射到了同一个槽位，也就是hash冲突（hash碰撞），可以通过链表解决【如 金庸与杨逍】</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>Hash索引只能用于对等比较(=，in)，不支持范围查询（between，&gt;，&lt; ，…）</li>
<li>无法利用索引完成排序操作</li>
<li>查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索 引</li>
</ul>
</li>
</ul>
<p> <strong>为什么InnoDB存储引擎选择使用B+tree索引结构?</strong></p>
<ul>
<li>相对于二叉树，层级更少，搜索效率高</li>
<li>对于<strong>B-tree</strong>，无论是叶子节点还是非叶子节点，<strong>都会保存数据</strong>，这样导致一页中存储 的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li>
<li>相对Hash索引，<strong>B+tree支持范围匹配及排序操作</strong></li>
</ul>
<hr>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对于表中主键创建的索引</td>
<td>默认自动创建, 只能 有一个</td>
<td>primary</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>unique</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是文本中的关键词，而不是比 较索引中的值</td>
<td>可以有多个</td>
<td>fullText</td>
</tr>
</tbody></table>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><ul>
<li><h4 id="聚集索引-和-二级索引"><a href="#聚集索引-和-二级索引" class="headerlink" title="聚集索引 和 二级索引"></a>聚集索引 和 二级索引</h4><p>在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引(Clustered Index)</td>
<td>将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据</td>
<td>必须有,而且只 有一个</td>
</tr>
<tr>
<td>二级索引(Secondary Index)</td>
<td>将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody></table>
<ul>
<li><p>如果<strong>存在</strong>主键，<strong>主键索引就是聚集索引</strong></p>
</li>
<li><p>如果<strong>不存在</strong>主键，将使用<strong>第一个</strong> 唯一索引 作为聚集索引</p>
</li>
<li><p>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索 引</p>
</li>
</ul>
<p>聚集索引和二级索引如下</p>
<p><img src="index.png" alt="index"></p>
<p>注：</p>
<ul>
<li>聚集索引的叶子节点下挂的是这一行的数据</li>
<li>二级索引的叶子节点下挂的是该字段值对应的主键值</li>
</ul>
<p>查找过程：</p>
<p>使用语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;Arm&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="index2.png" alt="index2"></p>
<ol>
<li>寻找 因为根据 name字段寻找Arm，所以到二级索引，因为 A 在 L 前，所以到左子树，A 在 G 之前定位到  Arm 查到主键值 10。</li>
<li>因为返回数据是 *，回到 聚集索引 找到 10，最终找到 10 对应的行。</li>
</ol>
<p>以上过程称为<strong>回表查询</strong></p>
<p><strong>由上可知</strong>，使用 id 比 使用 name 查询速度更快 </p>
<blockquote>
<p>回表查询： </p>
<p>这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h2><ul>
<li><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span> <span class="operator">|</span> fulltext] index index_name <span class="keyword">on</span> table_name (index_col_name,...);</span><br></pre></td></tr></table></figure>

<p><code>[unique | fulltext] </code>:为可选项，若不选，则创建的常规索引</p>
<p><code>(index_col_name,...)</code>：中表示可以一个索引可以关联多个字段，若 一个索引关联一个字段：<strong>单列索引</strong>；若一个索引关联了多个字段 则称之为：<strong>联合索引（组合索引）</strong> </p>
<p><strong>注：如果使用联合索引：使用最频繁的字段放在左侧，根据频繁成都从重到轻，要遵循 最左前缀原则</strong> </p>
</li>
<li><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index index_name <span class="keyword">on</span> table_name;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h2><ul>
<li><h4 id="SQL执行频率"><a href="#SQL执行频率" class="headerlink" title="SQL执行频率"></a>SQL执行频率</h4><p>MySQL 客户端连接成功后，通过 <code>show [session|global] status</code> 命令可以提供服务器状态信 息。通过如下指令，可以查看当前数据库的<code>INSERT、UPDATE、DELETE、SELECT</code>的访问频次：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session 是查看当前会话 ;</span></span><br><span class="line"><span class="comment">-- global 是查询全局数据 ;</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="q.png" alt="q"></p>
</li>
<li><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志。</p>
<p>使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查看系统变量 slow_query_log</p>
<p><img src="slow.png" alt="slow"></p>
<p>使用以下指令打开</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="profile详情"><a href="#profile详情" class="headerlink" title="profile详情"></a>profile详情</h4><p>show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling 参数，能够看到当前MySQL是否支持profile操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@have</span>_profiling ;</span><br></pre></td></tr></table></figure>

<p>默认profiling是关闭的，可以通过set语句在session/global级别开启profiling：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>profiling已经被打开，我们所执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去 了。 我们直接执行如下的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;白起&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_sku;</span><br></pre></td></tr></table></figure>

<p>执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看每一条SQL的耗时基本情况</span></span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"><span class="comment">-- 查看指定query_id的SQL语句各个阶段的耗时情况</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line"><span class="comment">-- 查看指定query_id的SQL语句CPU的使用情况</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h4><p>explain 或者 desc命令获取 MySQL 如何执行 select 语句的信息，包括在 select 语句执行 过程中表如何连接和连接的顺序。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 直接在select语句之前加上关键字 explain / desc</span></span><br><span class="line">explain <span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">desc</span> <span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure>

<p>在命令行中的效果：</p>
<p><img src="cmd.png" alt="cmd"></p>
<p>一下表格为对每列的解释</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序 (i<strong>d相同，执行顺序从上到下；id不同，值越大，越先执行</strong>)。</td>
</tr>
<tr>
<td>select_type</td>
<td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接 或者子查询）、PRIMARY（主查询，即外层的查询）、 UNION（UNION 中的第二个或者后面的查询语句）、 SUBQUERY（SELECT/WHERE之后包含了子查询）等</td>
</tr>
<tr>
<td>type</td>
<td>表示连接类型，<strong>性能由好到差</strong>的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。</td>
</tr>
<tr>
<td>possible_key</td>
<td>显示可能应用在这张表上的索引，一个或多个。</td>
</tr>
<tr>
<td>key_len</td>
<td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</td>
</tr>
<tr>
<td>rows</td>
<td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值， 可能并不总是准确的</td>
</tr>
<tr>
<td>filtered</td>
<td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。（比如根据主键去查，我们只读取了一行数据，返回也只返回了一行，那么  filtered=100% ，性能最好）</td>
</tr>
<tr>
<td>key</td>
<td><strong>实际使用的索引</strong>，如果为NULL，则没有使用索引。</td>
</tr>
<tr>
<td>Extra</td>
<td>额外的信息</td>
</tr>
</tbody></table>
<p><strong>id示例</strong>（后面省略）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+----+</span><br><span class="line">| id |     </span><br><span class="line">+----+</span><br><span class="line">|  1 |     表1</span><br><span class="line">+----+</span><br><span class="line">|  1 |     表2</span><br><span class="line">+----+</span><br><span class="line">|  2 |     表3</span><br><span class="line">+----+</span><br><span class="line">|  3 |     表4</span><br><span class="line">+----+</span><br></pre></td></tr></table></figure>

<p>如上图：表的执行顺序为  表4 -&gt;表3-&gt;表1-&gt;表2</p>
<p><strong>type：</strong></p>
<p>当我们根据<strong>主键</strong>或<strong>唯一索引</strong>进行访问时是 <strong>const</strong>，当使用<strong>非唯一索引</strong>时是 <strong>ref</strong> ，优化时尽量不要出现 all ，all是全表扫描，性能比较低</p>
</li>
</ul>
<hr>
<h2 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h2><ul>
<li><h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。<strong>如果跳跃某一列，索引将会部分失效(后面的字段索引失效)</strong></p>
<p>例：</p>
<p>查看tb_user表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure>

<p><img src="index3.png" alt="index3"></p>
<p><code>porfession、age、status</code>为联合索引，所以就必须要保证最左边的列存在，所以<code>profession</code>必须存在；且<strong>不能跳过中间的某一列</strong>，如果中间跳过某一列，那么<strong>后面的索引将会失效</strong>，也就是说 <code>age</code> 不能跳过</p>
<p>查看执行计划：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="string">&#x27;31&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="string">&#x27;31&#x27;</span><span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;0&#x27;</span> ;</span><br><span class="line"><span class="comment">-- 或改变一下顺序，执行效果一样</span></span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> age<span class="operator">=</span><span class="string">&#x27;31&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 最左前缀法则，只关注存不存在，不关注顺序</span></span><br></pre></td></tr></table></figure>

<p><img src="index4.png" alt="index4"></p>
<p>在key_len中看到一个为49，一个为54，就可以知道<code>status=&#39;0&#39;的索引长度为 5</code></p>
<p>去掉<code>profession=&#39;软件工程&#39;字段</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> age<span class="operator">=</span><span class="string">&#x27;31&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="index5.png" alt="index5"></p>
<p>此时就是走的全盘扫描，因为<strong>不满足最左前缀法则</strong></p>
<p><strong>注：最左前缀法则，只关注存不存在，不关注顺序</strong></p>
</li>
<li><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>联合索引中，出现范围查询  ( &gt; , &lt; )，范围查询右侧的列索引失效。</p>
<p><strong>注：在业务允许的情况下，尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，而避免使用 &gt; 或 &lt;</strong></p>
</li>
<li><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><ul>
<li><h5 id="索引列运算"><a href="#索引列运算" class="headerlink" title="索引列运算"></a>索引列运算</h5><p>不要在索引列上进行运算操作， 否则索引将失效。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;17799990015&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="dex6.png" alt="dex6"></p>
<p>查询到结果，使用了索引</p>
<p>使用subString（）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> <span class="built_in">substring</span>(phone,<span class="number">10</span>,<span class="number">2</span>) <span class="operator">=</span> <span class="string">&#x27;15&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="dex7.png" alt="dex7"></p>
<p>查询到结果，没有使用索引</p>
</li>
<li><h5 id="字符串不加引号"><a href="#字符串不加引号" class="headerlink" title="字符串不加引号"></a>字符串不加引号</h5><p>字符串类型字段使用时，不加引号，，可以查询出来，但索引将失效。</p>
</li>
<li><h5 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h5><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效（<strong>只要在前面加入了 %，索引就会失效</strong>）</p>
</li>
<li><h5 id="or连接条件"><a href="#or连接条件" class="headerlink" title="or连接条件"></a>or连接条件</h5><p>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会 被用到。 （也就是 or 两边都必须有索引）</p>
</li>
<li><h5 id="数据分布影响"><a href="#数据分布影响" class="headerlink" title="数据分布影响"></a>数据分布影响</h5><p>如果MySQL评估使用索引比全表更慢，则不使用索引</p>
</li>
</ul>
</li>
<li><h4 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h4><p>示例：</p>
<p>假设<code>profession</code>有  联合索引  和  单列索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 为 profession创建单列索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_pro <span class="keyword">on</span> tb_user(profession);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 展示执行计划</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="dex8.png" alt="dex8"></p>
<p>可以看到 查询走的 联合索引 ，这是MySQL自动选择的结果。</p>
<p>如果我们要指定使用哪个索引可以吗？ 此时就可以借助于 MySQL的SQL提示来完成。</p>
<p><strong>SQL提示</strong>：是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优 化操作的目的。</p>
<ul>
<li><p><code>use index</code> ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进 行评估）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user use index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>ignore index</code> ： 忽略指定的索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user ignore index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>force index</code> ： 强制使用索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user force index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>覆盖索引是指 查询使用了索引，并 且需要返回的列，在该索引中已经全部能够找到</p>
<p>**注：尽量使用覆盖索引，减少select ***</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1</span></span><br><span class="line">explain <span class="keyword">select</span> id, profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span><span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line">explain <span class="keyword">select</span> id,profession,age, status <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3</span></span><br><span class="line">explain <span class="keyword">select</span> id,profession,age, status, name <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status<span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="dex9.png" alt="dex9"></p>
<table>
<thead>
<tr>
<th>Extra</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Using where; Using Index</td>
<td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需 要回表查询数据</td>
</tr>
<tr>
<td>Using index condition</td>
<td>查找使用了索引，但是需要回表查询数据</td>
</tr>
</tbody></table>
<p>解释：</p>
<p>语句1 和语句2  直接可以走 <strong>联合索引</strong> 找到， <strong>查询一次</strong></p>
<p>但是语句3 ，多了一个 <code>name</code>字段，联合索引走完后找到 id，再回表查询通过 id 找到 name， <strong>查询两次</strong></p>
<p>语句4 直接通过 id 寻找，走聚集索引，<strong>查询一次</strong></p>
<p>如下图</p>
<p><img src="index.png" alt="index"></p>
<p>由此可见，语句1 和 语句2 效率高于 语句3 和 语句4，因为后两句要回表查询。</p>
<p><strong>结论：要避免使用 <code>select *</code>，因为很容易出现回表查询</strong></p>
</li>
<li><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当字段类型为字符串（varchar，text等）时，有时候需要索引很长的字符串，这会让 索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建 立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<ul>
<li><p>语法   （ n 为前缀索引长度）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建前缀索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_xxxx <span class="keyword">on</span> table_name(<span class="keyword">column</span>(n)) ;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<p>为tb_user表的email字段，建立长度为5的前缀索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_email_5 <span class="keyword">on</span> tb_user(email(<span class="number">5</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>前缀长度</p>
<p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值， 索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email,<span class="number">1</span>,<span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user ;</span><br></pre></td></tr></table></figure></li>
<li><p>前缀索引查询流程</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;lvbu666@163.com&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="qina.png" alt="qina"></p>
<ol>
<li>首先经过 <strong>id</strong> 建立 <strong>聚集索引</strong>，再根据 <strong>email 的前5位</strong>建立 <strong>辅助索引</strong>（为什么根据前 5位？ 因为前 5位就有很好的区分度）</li>
<li>取 <code>&#39;lvbu666@163.com&#39;</code>前五位到 <strong>辅助索引</strong> 去查询 </li>
<li>拿到 id=1，再到 聚集索引 查找</li>
<li>匹配聚集索引 中的 id=1， 再拿出 id=1 中的<code>row</code>的 <code>email</code>与 语句传入 <code>email</code>进行匹配 ，如果是，则返回 row ； 如果不是，则继续沿链表继续向下寻找</li>
</ol>
</li>
</ul>
</li>
<li><h4 id="单列索引与联合索引"><a href="#单列索引与联合索引" class="headerlink" title="单列索引与联合索引"></a>单列索引与联合索引</h4><p>单列索引：即一个索引只包含单个列。</p>
<p>联合索引：即一个索引包含了多个列。</p>
<p>示例：</p>
<p><img src="index7.png" alt="index7"></p>
<p>如上图，<code>phone</code>和<code>name</code>都为单列索引</p>
<p>使用以下语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,name,phone <span class="keyword">from</span> tb_user <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;韩信&#x27;</span> <span class="keyword">and</span> phone<span class="operator">=</span><span class="string">&#x27;17799990010&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="index6.png" alt="index6"></p>
<p>由图可见，可以看到这样查询需要<strong>回表查询</strong>，（MySQL 会在两个索引中自动选择更高效索引进行匹配）</p>
<p>当我们建立联合索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index idx_user_phone_name <span class="keyword">on</span> tb_user(phone,name);</span><br></pre></td></tr></table></figure>

<p><img src="index8.png" alt="index8"></p>
<p>此时，查询时，就走了联合索引，而在联合索引中包含 phone、name的信息，在叶子节点下挂的是对 应的主键id，所以查询是无需回表查询的</p>
<p>对应以上，情况如下</p>
<p><img src="indx7.png" alt="indx7"></p>
<blockquote>
<p>注1：<code>create unique index idx_user_phone_name on tb_user(phone,name);</code>此语句中<code>tb_user(phone,name)</code>的<code>phone</code>和<code>name</code>，颠倒这两个字段的顺序是不一样的（最左前缀法），所以在选择顺序时，需要斟酌。</p>
<p>注2：如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。</p>
</blockquote>
</li>
<li><h4 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h4><ul>
<li> 针对于数据量较大（100W+），且查询<strong>比较频繁</strong>的表建立索引</li>
<li> 针对于常作为<strong>查询条件（where）</strong>、<strong>排序（order by）</strong>、<strong>分组（group by）</strong>操作的字段建立索引</li>
<li> 尽量<strong>选择区分度高的列</strong>作为索引，<strong>尽量建立唯一索引</strong>，区分度越高，使用索引的效率越高</li>
<li> 如果是<strong>字符串类型</strong>的字段，<strong>字段的长度较长</strong>，可以针对于字段的特点，<strong>建立前缀索引</strong></li>
<li> <strong>尽量使用联合索引</strong>，<strong>减少单列索引</strong>，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率</li>
<li> 要<strong>控制索引的数量</strong>，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响<strong>增、删、改</strong>的效率</li>
<li> 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定哪个索引最有效地用于查询</li>
</ul>
</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Arno Dorian</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://example.com/2022/08/25/2-%E7%B4%A2%E5%BC%95/">http://example.com/2022/08/25/2-%E7%B4%A2%E5%BC%95/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/MySQL/"># MySQL</a>
                    
                        
                </span>
            </div>
			
			<!-- ******************************************************* -->
			
			<!-- 支持一下的按钮与图片 -->
			
			<div class="reward" id="reward">
			
			<div class="sponser">
			
			<div class="sponser_btn">支持一下</div>
			
			<div class="sponser_img">
			
			<div class="sponser_container">
			
			
			
			<div class="sponser_body">
			

			<div class="alipay">
			
			
			
			<div> 
			
			
			<img class="sponser_alipay" src="/image/QR.jpg">
			
			</div>
			
			</div>
			
			</div>
			
			</div>
			
			</div>
			
			</div>
			
			</div>
			
			<!-- **************************************************** -->
			
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2022/08/25/2-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">2_存储引擎</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Arno Dorian | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a>
		 |
		
		 <!-- 访客数量 -->
		
		 
		
		 <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<span class="site-uv">

 总访客量:

 <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>

</span>&nbsp;





<span class="site-pv">

 | 总访问量:

 <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>

</span>


		
		 

		</span>
    </div>
</footer>

    </div>
</body>

</html>